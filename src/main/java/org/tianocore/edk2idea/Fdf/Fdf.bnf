{
  parserClass="org.tianocore.edk2idea.Fdf.FdfParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Fdf"
  psiImplClassSuffix="Impl"
  psiPackage="org.tianocore.edk2idea.Fdf.psi"
  psiImplPackage="org.tianocore.edk2idea.Fdf.psi.impl"

  elementTypeHolderClass="org.tianocore.edk2idea.Fdf.FdfTypes"
  elementTypeClass="org.tianocore.edk2idea.Fdf.psi.FdfElementType"
  tokenTypeClass="org.tianocore.edk2idea.Fdf.psi.FdfTokenType"
  
  tokens=[
    EQ="="
    PIPE="|"
    DOT="."
    COMMA=","
    COLON=":"
    LBRACE="{"
    RBRACE="}"
    RBRACE="}"
    LBRACKET="["
    RBRACKET="]"
    LT="<"
    GT=">"
    
    // Depex operators
    DEPEX_AND="AND"
    DEPEX_OR="OR"
    DEPEX_NOT="NOT"
    
    // Preprocessor
    INCLUDE="!include"
    IFDEF="!ifdef"
    IFNDEF="!ifndef"
    IF="!if"
    ELSEIF="!elseif"
    ELSE="!else"
    ENDIF="!endif"
    ERROR="!error"
    
    // Comments
    COMMENT="regexp:#[^\r\n]*"
    
    MACRO_REF="regexp:\$\([a-zA-Z0-9_\.]+\)"
    LPAREN="("
    RPAREN=")"
    EQ_EQ="=="
    NE="!="
    LE="<="
    GE=">="
    // AND="&&" - Conflicts with DEPEX_AND? No, usually distinct contexts
    AND_OP="&&"
    OR_OP="||"
    
    // FDF Specific
    APRIORI="APRIORI"
    INF="INF"
    FILE="FILE"
    SECTION="SECTION"
    SET="SET"
    MINUS="-"
    DIV="/"
    MOD="%"
    BIT_AND="&"
    XOR="^"
    BIT_NOT="~"
    PLUS="+"
  ]
}

fdfFile ::= (fdfSection | directiveStatement | headlessFdfStatement | emptyLineOrComment)*

headlessFdfStatement ::= 
    infStatement | 
    fileStatement | 
    aprioriBlock |
    sectionStatement |
    fdRegion | 
    setStatement |
    genericProperty CRLF

genericProperty ::= key EQ (valueString | arrayBlock)

// Directive
directiveStatement ::= 
    includeStatement | 
    ifStatement | 
    elseStatement | 
    endifStatement |
    errorStatement
    
setStatement ::= SET key EQ valueString CRLF

includeStatement ::= INCLUDE path CRLF
ifStatement ::= (IF | IFDEF | IFNDEF | ELSEIF) valueString CRLF
elseStatement ::= ELSE CRLF
endifStatement ::= ENDIF CRLF
errorStatement ::= ERROR valueString CRLF

// Common
emptyLineOrComment ::= COMMENT? CRLF

// Generic Sections
fdfSection ::= (
    definesSection |
    fdSection |
    fvSection |
    ruleSection |
    capsuleSection |
    optionRomSection |
    unknownSection
)

// Section Headers
private sectionHeader ::= 
    DEFINES_SECTION_HEADER | 
    FD_SECTION_HEADER | 
    FV_SECTION_HEADER | 
    RULE_SECTION_HEADER | 
    CAPSULE_SECTION_HEADER | 
    OPTION_ROM_SECTION_HEADER |
    UNKNOWN_SECTION_HEADER

unknownSection ::= UNKNOWN_SECTION_HEADER CRLF (unknownStatement | emptyLineOrComment)*
unknownStatement ::= !sectionHeader regexLine CRLF
regexLine ::= "[^\r\n]+" // Validation placeholder

// Defines
definesSection ::= DEFINES_SECTION_HEADER CRLF (defineStatement | directiveStatement | emptyLineOrComment | setStatement)*
defineStatement ::= defineEntry CRLF
defineEntry ::= key EQ valueString

// FD
fdSection ::= FD_SECTION_HEADER CRLF (fdStatement | directiveStatement | emptyLineOrComment | setStatement)*
fdStatement ::= (fdRegion | fdProperty) CRLF
fdProperty ::= key EQ (valueString | arrayBlock)
fdRegion ::= (HEX_NUMBER | MACRO_REF | IDENTIFIER | PATH_STRING) PIPE (HEX_NUMBER | MACRO_REF | IDENTIFIER | PATH_STRING) (CRLF)? (emptyLineOrComment)* (fdRegionBlock)?
fdRegionBlock ::= "FV" EQ IDENTIFIER

// FV
fvSection ::= FV_SECTION_HEADER CRLF (fvStatement | directiveStatement | emptyLineOrComment | setStatement)*
fvStatement ::= (fvProperty | aprioriBlock | infStatement | fileStatement | sectionStatement) CRLF
fvProperty ::= key EQ (valueString | arrayBlock)
aprioriBlock ::= APRIORI IDENTIFIER LBRACE CRLF (infStatement | directiveStatement | emptyLineOrComment)* RBRACE
infStatement ::= INF (infOption)* path CRLF
infOption ::= key EQ restrictedValue
private restrictedValue ::= IDENTIFIER | STRING | NUMBER | HEX_NUMBER | GUID | MACRO_REF | PATH_STRING

// Array Block
arrayBlock ::= LBRACE (arrayElement | directiveStatement | emptyLineOrComment)* RBRACE
private arrayElement ::= (HEX_NUMBER | NUMBER | STRING | IDENTIFIER | arrayBlock | COMMA | valueString)

sectionStatement ::= SECTION (valueString)* (LBRACE CRLF (sectionStatement | directiveStatement | emptyLineOrComment)* RBRACE)? CRLF

fileStatement ::= FILE (valueString)* LBRACE CRLF (ruleStatement | directiveStatement | emptyLineOrComment)* RBRACE

simpleFileSection ::= valueString CRLF
fileProperty ::= key EQ (valueString | arrayBlock) CRLF {pin=2}

// Rule
ruleSection ::= RULE_SECTION_HEADER CRLF (ruleStatement | directiveStatement | emptyLineOrComment | setStatement)*
ruleStatement ::= (nestedFileStatement | ruleBlock | simpleFileSection | ruleProperty) CRLF?

nestedFileStatement ::= fileStatement CRLF

ruleBlock ::= (valueString)* LBRACE CRLF (ruleStatement | directiveStatement | emptyLineOrComment)* RBRACE
ruleProperty ::= key EQ (valueString | arrayBlock)

// Capsule ( Placeholder structure )
capsuleSection ::= CAPSULE_SECTION_HEADER CRLF (capsuleStatement | directiveStatement | emptyLineOrComment | setStatement)*
capsuleStatement ::= capsuleProperty CRLF
capsuleProperty ::= key EQ valueString

// OptionRom ( Placeholder structure )
optionRomSection ::= OPTION_ROM_SECTION_HEADER CRLF (optionRomStatement | directiveStatement | emptyLineOrComment | setStatement)*
optionRomStatement ::= optionRomProperty CRLF
optionRomProperty ::= key EQ valueString

// Generic Block
blockStatement ::= LBRACE CRLF (blockContent | emptyLineOrComment)* RBRACE
blockContent ::= fdfSection | directiveStatement | key

// Values
valueString ::= (IDENTIFIER | NUMBER | STRING | DOT | COMMA | HEX_NUMBER | PATH_STRING | PIPE | MINUS | PLUS | STAR | DIV | MOD | BIT_AND | XOR | BIT_NOT | GUID | COLON | EQ | MACRO_REF | LPAREN | RPAREN | EQ_EQ | NE | LE | GE | AND_OP | OR_OP | APRIORI | INF | FILE | SECTION | SET)+

path ::= (PATH_STRING | IDENTIFIER | MACRO_REF | DOT | DIV)+ {
  mixin="org.tianocore.edk2idea.Fdf.psi.impl.FdfPathMixin"
}

key ::= key_part+
private key_part ::= IDENTIFIER | PATH_STRING | NUMBER | HEX_NUMBER | STAR | MINUS | DOT
